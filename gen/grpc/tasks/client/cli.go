// Code generated by goa v3.2.3, DO NOT EDIT.
//
// tasks gRPC client CLI support package
//
// Command:
// $ goa gen tasks/design

package client

import (
	"encoding/json"
	"fmt"
	taskspb "tasks/gen/grpc/tasks/pb"
	tasks "tasks/gen/tasks"

	goa "goa.design/goa/v3/pkg"
)

// BuildListPayload builds the payload for the tasks list endpoint from CLI
// flags.
func BuildListPayload(tasksListView string) (*tasks.ListPayload, error) {
	var err error
	var view *string
	{
		if tasksListView != "" {
			view = &tasksListView
			if view != nil {
				if !(*view == "default" || *view == "tiny") {
					err = goa.MergeErrors(err, goa.InvalidEnumValueError("view", *view, []interface{}{"default", "tiny"}))
				}
			}
			if err != nil {
				return nil, err
			}
		}
	}
	v := &tasks.ListPayload{}
	v.View = view

	return v, nil
}

// BuildShowPayload builds the payload for the tasks show endpoint from CLI
// flags.
func BuildShowPayload(tasksShowMessage string, tasksShowView string) (*tasks.ShowPayload, error) {
	var err error
	var message taskspb.ShowRequest
	{
		if tasksShowMessage != "" {
			err = json.Unmarshal([]byte(tasksShowMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"id\": \"Saepe accusamus illo.\"\n   }'")
			}
		}
	}
	var view *string
	{
		if tasksShowView != "" {
			view = &tasksShowView
			if view != nil {
				if !(*view == "default" || *view == "tiny") {
					err = goa.MergeErrors(err, goa.InvalidEnumValueError("view", *view, []interface{}{"default", "tiny"}))
				}
			}
			if err != nil {
				return nil, err
			}
		}
	}
	v := &tasks.ShowPayload{
		ID: message.Id,
	}
	v.View = view

	return v, nil
}

// BuildAddPayload builds the payload for the tasks add endpoint from CLI flags.
func BuildAddPayload(tasksAddMessage string) (*tasks.Task, error) {
	var err error
	var message taskspb.AddRequest
	{
		if tasksAddMessage != "" {
			err = json.Unmarshal([]byte(tasksAddMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"assignee\": {\n         \"email\": \"ehabterra@hotmail.com\",\n         \"firstname\": \"Ehab\",\n         \"isactive\": false,\n         \"lastname\": \"Terra\",\n         \"role\": \"admin\"\n      },\n      \"created_date\": \"1995-12-15T01:16:46Z\",\n      \"description\": \"Task description\",\n      \"due_date\": \"2004-07-22T01:49:19Z\",\n      \"owner\": {\n         \"email\": \"ehabterra@hotmail.com\",\n         \"firstname\": \"Ehab\",\n         \"isactive\": false,\n         \"lastname\": \"Terra\",\n         \"role\": \"admin\"\n      },\n      \"status\": \"Pending\",\n      \"title\": \"New task title\",\n      \"updated_date\": \"1994-02-15T11:22:43Z\"\n   }'")
			}
		}
	}
	v := &tasks.Task{
		Title:       message.Title,
		Description: message.Description,
		CreatedDate: message.CreatedDate,
		UpdatedDate: message.UpdatedDate,
		Status:      message.Status,
	}
	if message.DueDate != "" {
		v.DueDate = &message.DueDate
	}
	if message.Owner != nil {
		v.Owner = protobufTaskspbStoredUserToTasksStoredUser(message.Owner)
	}
	if message.Assignee != nil {
		v.Assignee = protobufTaskspbStoredUserToTasksStoredUser(message.Assignee)
	}

	return v, nil
}

// BuildUpdatePayload builds the payload for the tasks update endpoint from CLI
// flags.
func BuildUpdatePayload(tasksUpdateMessage string) (*tasks.UpdatePayload, error) {
	var err error
	var message taskspb.UpdateRequest
	{
		if tasksUpdateMessage != "" {
			err = json.Unmarshal([]byte(tasksUpdateMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"id\": \"Et unde velit sapiente voluptatum.\",\n      \"task\": {\n         \"assignee\": {\n            \"email\": \"ehabterra@hotmail.com\",\n            \"firstname\": \"Ehab\",\n            \"isactive\": false,\n            \"lastname\": \"Terra\",\n            \"role\": \"admin\"\n         },\n         \"created_date\": \"1977-08-23T17:31:33Z\",\n         \"description\": \"Task description\",\n         \"due_date\": \"1994-02-04T20:22:05Z\",\n         \"id\": \"Dolor eos dolorem numquam odio aspernatur et.\",\n         \"owner\": {\n            \"email\": \"ehabterra@hotmail.com\",\n            \"firstname\": \"Ehab\",\n            \"isactive\": false,\n            \"lastname\": \"Terra\",\n            \"role\": \"admin\"\n         },\n         \"status\": \"Pending\",\n         \"title\": \"New task title\",\n         \"updated_date\": \"1994-11-14T18:35:02Z\"\n      }\n   }'")
			}
		}
	}
	v := &tasks.UpdatePayload{
		ID: message.Id,
	}
	if message.Task != nil {
		v.Task = protobufTaskspbStoredTaskToTasksStoredTask(message.Task)
	}

	return v, nil
}

// BuildRemovePayload builds the payload for the tasks remove endpoint from CLI
// flags.
func BuildRemovePayload(tasksRemoveMessage string) (*tasks.RemovePayload, error) {
	var err error
	var message taskspb.RemoveRequest
	{
		if tasksRemoveMessage != "" {
			err = json.Unmarshal([]byte(tasksRemoveMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"id\": \"Vel veritatis ea assumenda vitae.\"\n   }'")
			}
		}
	}
	v := &tasks.RemovePayload{
		ID: message.Id,
	}

	return v, nil
}

// BuildStatusPayload builds the payload for the tasks status endpoint from CLI
// flags.
func BuildStatusPayload(tasksStatusMessage string) (*tasks.StatusPayload, error) {
	var err error
	var message taskspb.StatusRequest
	{
		if tasksStatusMessage != "" {
			err = json.Unmarshal([]byte(tasksStatusMessage), &message)
			if err != nil {
				return nil, fmt.Errorf("invalid JSON for message, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"id\": \"Rem assumenda deserunt doloremque.\",\n      \"status\": \"Closed\"\n   }'")
			}
		}
	}
	v := &tasks.StatusPayload{
		ID:     message.Id,
		Status: message.Status,
	}

	return v, nil
}
